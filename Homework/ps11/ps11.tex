%me=0 student solutions (ps file), me=1 - my solutions (sol file), me=2 - assignment (hw file)
\def\me{0}
\def\num{11}  %homework number
\def\due{Wednesday, April 29}  %due date
\def\course{CSCI-UA.0310-004/005 Basic Algorithms} %course name, changed only once
\def\name{Jason Yao}   %student changes (instructor keeps!)
%
\iffalse
INSTRUCTIONS: replace # by the homework number.
(if this is not ps#.tex, use the right file name)

  Clip out the ********* INSERT HERE ********* bits below and insert
appropriate TeX code.  Once you are done with your file, run

  ``latex ps#.tex''

from a UNIX prompt.  If your LaTeX code is clean, the latex will exit
back to a prompt.  To see intermediate results, type

  ``xdvi ps#.dvi'' (from UNIX prompt)
  ``yap ps#.dvi'' (if using MikTex in Windows)

after compilation. Once you are done, run

  ``dvips ps#.dvi''

which should print your file to the nearest printer.  There will be
residual files called ps#.log, ps#.aux, and ps#.dvi.  All these can be
deleted, but do not delete ps1.tex. To generate postscript file ps#.ps,
run

  ``dvips -o ps#.ps ps#.dvi''

I assume you know how to print .ps files (``lpr -Pprinter ps#.ps'')
\fi
%
\documentclass[11pt]{article}
\usepackage{amsfonts, amsmath}
\usepackage{latexsym}
\usepackage{listings}

%\usepackage{tikz}

\setlength{\oddsidemargin}{.0in}
\setlength{\evensidemargin}{.0in}
\setlength{\textwidth}{6.5in}
\setlength{\topmargin}{-0.4in}
\setlength{\textheight}{8.5in}

\newcommand{\handout}[5]{
   \renewcommand{\thepage}{#1, Page \arabic{page}}
   \noindent
   \begin{center}
   \framebox{
      \vbox{
    \hbox to 5.78in { {\bf \course} \hfill #2 }
       \vspace{4mm}
       \hbox to 5.78in { {\Large \hfill #5  \hfill} }
       \vspace{2mm}
       \hbox to 5.78in { {\it #3 \hfill #4} }
      }
   }
   \end{center}
   \vspace*{4mm}
}

\newcounter{pppp}
\newcommand{\prob}{\arabic{pppp}}  %problem number
\newcommand{\increase}{\addtocounter{pppp}{1}}  %problem number

%first argument desription, second number of points
\newcommand{\newproblem}[2]{
\ifnum\me=0
\ifnum\prob>0 \newpage \fi
\increase
\setcounter{page}{1}
\handout{\name, Homework \num, Problem \arabic{pppp}}{\today}{Name: \name}{Due:
\due}{Solutions to Problem \prob\ of Homework \num\ (#2)}
\else
\increase
\section*{Problem \num-\prob~(#1) \hfill {#2}}
\fi
}

%\newcommand{\newproblem}[2]{\increase
%\section*{Problem \num-\prob~(#1) \hfill {#2}}
%}

\def\squarebox#1{\hbox to #1{\hfill\vbox to #1{\vfill}}}
\def\qed{\hspace*{\fill}
        \vbox{\hrule\hbox{\vrule\squarebox{.667em}\vrule}\hrule}}
\newenvironment{solution}{\begin{trivlist}\item[]{\bf Solution:}}
                      {\qed \end{trivlist}}
\newenvironment{solsketch}{\begin{trivlist}\item[]{\bf Solution Sketch:}}
                      {\qed \end{trivlist}}
\newenvironment{code}{\begin{tabbing}
12345\=12345\=12345\=12345\=12345\=12345\=12345\=12345\= \kill }
{\end{tabbing}}

%\newcommand{\eqref}[1]{Equation~(\ref{eq:#1})}

\newcommand{\proc}[1]{\textnormal{\scshape#1}}
\newcommand{\eof}{\proc{eof}}

\newcommand{\hint}[1]{({\bf Hint}: {#1})}
%Put more macros here, as needed.
\newcommand{\room}{\medskip\ni}
\newcommand{\brak}[1]{\langle #1 \rangle}
\newcommand{\bit}[1]{\{0,1\}^{#1}}
\newcommand{\zo}{\{0,1\}}
\newcommand{\C}{{\cal C}}

\newcommand{\nin}{\not\in}
\newcommand{\set}[1]{\{#1\}}
\renewcommand{\ni}{\noindent}
\renewcommand{\gets}{\leftarrow}
\renewcommand{\to}{\rightarrow}
\newcommand{\assign}{:=}

\newcommand{\AND}{\wedge}
\newcommand{\OR}{\vee}

\newcommand{\For}{\mbox{\bf For }}
\newcommand{\To}{\mbox{\bf to }}
\newcommand{\Do}{\mbox{\bf Do }}
\newcommand{\If}{\mbox{\bf If }}
\newcommand{\Then}{\mbox{\bf Then }}
\newcommand{\Else}{\mbox{\bf Else }}
\newcommand{\While}{\mbox{\bf While }}
\newcommand{\Repeat}{\mbox{\bf Repeat }}
\newcommand{\Until}{\mbox{\bf Until }}
\newcommand{\Return}{\mbox{\bf Return }}
\newcommand{\Swap}{\mbox{\bf Swap }}

\begin{document}

\ifnum\me=0
%\handout{PS\num}{\today}{Name: Jason Yao}{Due:
%\due}{Solutions to Problem Set \num}
%
%I collaborated with *********** INSERT COLLABORATORS HERE (INDICATING
%SPECIFIC PROBLEMS) *************.
\fi
\ifnum\me=1
\handout{PS\num}{\today}{Name: Jason Yao}{Due: \due}{Solution
{\em Sketches} to Problem Set \num}
\fi
\ifnum\me=2
\handout{PS\num}{\today}{Lecturer: Yevgeniy Dodis}{Due: \due}{Problem
Set \num}
\fi

\newproblem{How NOT to Read All Edges}{8 points}

\begin{itemize}
\item[(a)] (5 points) Design $O(n)$ algorithm to test if a given {\em undirected}
graph $G$ is acyclic. Notice, the running time of your algorithm
should not depend on the number of edges $m$!\\
\hint{Could you argue fater termination of a regular DFS tester
on undirected graph?}

\ifnum\me<2
\begin{solution}

\lstinputlisting[language=C]{problem1a.c}
\end{solution}
\fi
\newpage

\item[(b)] (3 points)  Extend the above algorithm to actually print the cycle, in
case $G$ is cyclic.

\ifnum\me<2
\begin{solution}

\lstinputlisting[language=C]{problem1b.c}
\end{solution}
\fi

\end{itemize}

\newproblem{No Pebbles, Please!} {10 points}

Your job is to arrange $n$ rambunctious children in a straight line, facing front, i.e., in the direction of the line. You are
given a list of $m$ statements of the form $i$ hates $j$. If $i$ hates $j$, then you do not want
put $i$ somewhere behind $j$, because then $i$ is capable of throwing a pebble at $j$.
\begin{itemize}
\item[(a)] (4 points) Give an algorithm that orders the line, (or says that it is not possible) in $O(m+n)$.
time.
\ifnum\me<2
\begin{solution}

We say that there are $n$ vertex (children), with a list of $m$ edges (statements) with direction. Direction is from some $i$ to some $j$ such that $i$ "hates" $j$. This forms a directed graph G, and we can order this line via BFS, assuming no cycles inside of G.

\lstinputlisting[language=C]{problem2a.c}
\end{solution}
\fi

\newpage

\item[(b)] (6 points) Suppose instead you want to arrange the children in rows, such that if $i$ hates $j$
then $i$ must be in a (strictly) lower numbered row than $j$. Give an efficient algorithm to
find the minimum number of rows needed, if it is possible.
\ifnum\me<2
\begin{solution}

\lstinputlisting[language=C]{problem2b.c}
\end{solution}
\fi
\end{itemize}

\newproblem{Changing One Edge Weight}{12 (+6) points}

Assume $G$ is an undirected graph with weight function $w$, and
$e_1\ldots e_m$ are the $m$ edges of $G$ sorted according to their
weight: $w(e_1)\le w(e_2)\le \ldots \le w(e_m)$. Imagine you just ran
the Kruskall's algorithm of $G$ and it output an MST $T$ of $G$. Now
assume that somebody changes the weight of a single edge $e_i$ from
$w(e_i)$ to some other value $w'$. For each of the following 4
scenarios, describe the fastest algorithm you can think of to
transform the original MST $T$ of $G$ to a new (and correct) MST $T'$
of $G$ after the edge weight change. Make sure you justify your
answer, and express your running time as a function of $m$ and $n$.

\begin{itemize}

\item[(a)] (4 points)  Assume $e_i\in T$ and $w'<w(e_i)$ (so we decreased an MST
edge).

\ifnum\me<2
\begin{solution}

A decrease an MST edge $w_2$ results in:

$w_1 \leq w_2$

MST stays the same


\end{solution}
\fi

\item[(b)] (4 points) Assume $e_i\not \in T$ and $w'<w(e_i)$ (so we decreased a
non-MST edge).\\
\hint{Compute the unique shortest path in $T$ between the two
end-points of $e_i$.}

\ifnum\me<2
\begin{solution}

decrease a non-MST edge, $w_i$

old MST + edge w

=> creates cycle in MSY

=> find edge with MAX weight 
     on this cycle => remove it
\end{solution}
\fi

\item[(c)] (4 points) Assume $e_i\not \in T$ and $w'>w(e_i)$ (so we increased a
non-MST edge).

\ifnum\me<2
\begin{solution}

increase a non MST edge

MST stays the same

\end{solution}
\fi

\item[(d)] {\bf Extra Credit:} (6 points) Assume $e_i\in T$ and $w'>w(e_i)$ (so
we increased an MST edge).\\
\hint{Try to find the smallest weight edge $e_j$ which should replace
$e_i$ under the new weight.}

\ifnum\me<2
\begin{solution}   ***************** INSERT YOUR SOLUTION HERE ***************   \end{solution}
\fi

\end{itemize}

\newproblem{Greedy MST} {11 points}

\begin{itemize}

\item[(a)] (5 points) Let $e$ be the maximum weight edge on some cycle of a
connected graph $G=(V,E)$. Prove that there exists an MST $T$ of $G' =
(V, E\backslash \{e\})$ which is also an MST of $G$. Namely, some MST
of $G$ does not include $e$.

\ifnum\me<2
\begin{solution}

if G has a cycle and $w_i$ is the max-weight edge on this cycle
=> there exists an MST of G such that $w_i$ does not exist in the set of MST

case 1 MST(G) does not have $w_i$ => proved

case 2

$w_i$ = fat edge on cycling

$w_i$ exists in the set of MST(G)
	remove $w_i$ => 2 disjoint subtrees
	
look at cycle from u $\rightarrow$ t
find edge ($u_{new}$, $t_{new}$),
$u_{new} \exists V_1$, $t_{new} \in V_2$

$\rightarrow$ new MST has weight $\leq$ old MST

($w_{new} \leq w_1$)





\end{solution}
\fi

\item[(b)] (2 points) Consider the following idea for a greedy algorithm for finding some minimal spanning tree in an undirected  weighted graph $G$:

\begin{itemize}
\item[(I)] find a cycle in $G$.
\vspace{-1ex}
\item[(II)] if there is no cycle, output $G$ and terminate;
\vspace{-1ex}
\item[(II)] else, if there is a cycle,
\begin{itemize}
\vspace{-1ex}
\item find an edge $e$ with maximum weight on this cycle;
\vspace{-1ex}
\item remove $e$ from the graph $G$;
\vspace{-1ex}
\item return to step (I).
\end{itemize}
\vspace{-1ex}
\end{itemize}

\noindent Prove correctness of this algorithm using induction and part (a).

\ifnum\me<2
\begin{solution}




\end{solution}
\fi

\item[(c)] (4 points) Describe details of the fastest implementation you can find for the algorithm in part (b) (or write a pseudocode), and analyze its complexity as a function of $n$ (number of vertices) and $m$ (number of edges).

\ifnum\me<2
\begin{solution}   ***************** INSERT YOUR SOLUTION HERE ***************   \end{solution}
\fi

\end{itemize}



\end{document}
